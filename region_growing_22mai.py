# -*- coding: utf-8 -*-
"""Region_growing_22mai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ANOGUZAHi_vM5fwNVnRHB9lju2wHi4pJ

# IMPORTS E DEF FUNÇÕES
"""

!pip install imutils
!pip install imagecodecs

import time
import tifffile
import numpy as np
import matplotlib.pyplot as plt
import cv2
import imutils
import imagecodecs
import random
from sklearn.metrics import confusion_matrix
from osgeo import gdal, ogr, osr

def IoU(esperada, obtida): #Calcula a métrica IoU para uma imagem segmentada, utilizando os valores esperados e os obtidos
    #Valores == zero (0), indicam uma região que não foi desmatada
    #Valores == um (1), indicam uma região que foi desmatada
    img_esperada = esperada.flatten()
    img_obtida = obtida.flatten()

    tn, fp, fn, tp = confusion_matrix(img_esperada, img_obtida).ravel()
    soma = tp + fp + fn
    out = (tp/soma, fp/soma, fn/soma)
    return out

def distancia_euclidiana(v1, v2):
    assert len(v1) == len(v2), 'Os vetores devem ter o mesmo tamanho'
    dif = np.array(v1) - np.array(v2) #diferença entre cada posição dos vetores
    sq = np.power(dif, 2) #valores quadráticos para cada valor de diferença
    soma = np.sum(sq) #somatório dos valores quadrátivos
    root = np.sqrt(soma) #raiz quadrata do somatório
    return root

def region_growing(img, coords, threshold, ignore=-999.): #se há algum valor a ser ignorado
    def N8(coord, limits): #define os 8 vizinhos e retorna suas coordenadas
        #PEGA 8 VIZINHOS
        #coord = np.array([coord, coord, coord, coord, coord, coord, coord, coord])
        #vet = np.array([(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]) # 8 vizinhos

        #PEGA 4 VIZINHOS
        coord = np.array([coord, coord, coord, coord])
        vet = np.array([(-1, 0), (0, -1), (0, 1), (1, 0)]) # 4 vizinhos

        neighbor = []

        for item in np.array(np.add(coord,vet)): #ignora as coordenadas de vizinhos que ultrapassam os limites da imagem
            if min(item) < 0:
                continue
            elif item[0] >= limits[0] or item[1] >= limits[1]:
                continue
            neighbor.append(list(item))

        return np.array(neighbor) # retorna os vizinhos

    out = np.zeros((img.shape[0],img.shape[1])) # cria o array de saída, inciado com 0s

    z_1000 = 1

    for i in range(0, len(coords)): # para cada coordenada selecionada faça
        coord = coords[i]

        if any(img[coord[0]][coord[1]]==-999.): # alguns pixels estão com valores que devem ser ignorados
            continue

        if out[coord[0]][coord[1]] == 1: # verifica se a coordenada atual já foi visualizada e se já foi adicionada na saída
            continue

        out[coord[0]][coord[1]] = 1 # se é a primeira vez que a coordenada atual é vizualizada ela é adicionada no vetor de saída
        #neighbors = N8(coord, img.shape) #define os vizinhos para testar a as condições ao redor da coordenada atual

        neighbors = [coord]
        neighbors = np.array(neighbors)

        z = 0

        #print('step: ', end='')
        while z < len(neighbors): # Para cada vizinho faça
            if z_1000 % 10000 == 0:
              print(f"coordenada {i} of {len(coords)-1}: {coords[i]}; vizinho geral: {z_1000}")
            neighbor = neighbors[z]
            if distancia_euclidiana(img[coord[0],coord[1]], img[neighbor[0],neighbor[1]]) <= threshold:
                # Se o vizinho que está sendo observado tem um distância menor que o threshold da coordenada original então ele será adicionada a imagem de saída
                out[neighbor[0]][neighbor[1]] = 1
                n = N8(neighbor, img.shape) #seleciona os vizinhos do vizinho atual
                for item in n:
                  if out[item[0]][item[1]] not in [1,-i-1]:
                    neighbors = np.append(neighbors, [item], 0)
                    out[item[0]][item[1]] = -i-1

            z += 1 # passa para o próximo vizinho
            z_1000 += 1

    #passa os valores negativos pra zero
    for i in range(out.shape[0]):
      for j in range(out.shape[1]):
        if out[i][j] < 0:
          out[i][j] = 0

    print(f"coordenada {len(coords)-1} of {len(coords)-1}: {coords[len(coords)-1]}; vizinho geral: {z_1000}")
    return out #retorna imagem de saída, mascara binária.

"""# ABRE IMAGEM E SELECIONA BANDAS"""

#escolha da imagem
img = tifffile.imread('/content/imagem_segment_south_mayo2024_v2.tif')
print(f"img.shape = {img.shape}")
#img = img+0.2

if len(img.shape) == 2:
  img = np.array(img.reshape(img.shape+(1,)))
  print(f"img.shape = {img.shape}")

print('Para cada banda os valores de mínimo e máximo são:')
for i in range(img.shape[2]):
    print(f'Mínimo = {np.nanmin(img[:,:,i])} e máximo = {np.nanmax(img[:,:,i])}')
print("")

#extrai bandas
bandas = []
for i in range(img.shape[2]):
  bandas += [img[:,:,i]]
  bandas[i] = np.array(bandas[i].reshape(bandas[i].shape+(1,)))

#escolha das bandas
num_bandas = [1,2,4]



img = np.concatenate([bandas[i] for i in num_bandas], axis=-1)
print(f"img.shape = {img.shape}")
img = np.nan_to_num(img, nan=-999., posinf=-999., neginf=-999.)

print('Para cada banda os valores de mínimo e máximo são:')
for i in range(img.shape[2]):
    print(f'Mínimo = {np.nanmin(img[:,:,i])} e máximo = {np.nanmax(img[:,:,i])}')

#normaliza pro máximo ser 1
array_img = np.zeros((img.shape[0], img.shape[1], img.shape[2]))
for i in range(img.shape[2]):
  array_img[:, :, i] = img[:, :, i] / img[:, :, i].max()

#transforma negativos em 0
for i in range(img.shape[0]):
  for j in range(img.shape[1]):
    for k in range(img.shape[2]):
      if array_img[i][j][k] < 0:
        array_img[i][j][k] = 0

plt.figure(figsize=(20, 5))
plt.imshow(array_img);

"""# IMAGEM ESPERADA (se necessário)

No estudo de caso partimos de uma imagem de referência para selecionar os pontos iniciais, e também para comparar com o resultado obtido. Para segmentar outras imagens, selecionando diretamente as coordenadas, por exemplo, pular essa parte.
"""

img_esperada = tifffile.imread('Bosque_No_Bosque_2022_south.tif')
print(img.shape)
print(img_esperada.shape)

# separa regiões da imagem de referência em matrizes diferentes,
# obtendo duas para cada valor, com shapes original e redimensionado
# valores 2 e 3: desmatamento
# valor 4: água
# valor 5: floresta
# obs: matrizes inicialmente formadas com valores booleanos
esperada2           = img_esperada == 2
esperada3           = img_esperada == 3
esperada4           = img_esperada == 4
esperada5           = img_esperada == 5
esperada23          = esperada2.astype(np.uint8) + esperada3.astype(np.uint8)
esperada4           = esperada4.astype(np.uint8)
esperada5           = esperada5.astype(np.uint8)
esperada23_resized  = cv2.resize(esperada23.copy(), (img.shape[1],img.shape[0]), interpolation=cv2.INTER_AREA)
esperada4_resized   = cv2.resize(esperada4.copy(), (img.shape[1],img.shape[0]), interpolation=cv2.INTER_AREA)
esperada5_resized   = cv2.resize(esperada5.copy(), (img.shape[1],img.shape[0]), interpolation=cv2.INTER_AREA)
print(esperada23.shape)
print(esperada23_resized.shape)

regiao = esperada23_resized
qtd_coords = 80

########################################################################################
#cria lista com coordenadas da regiao escolhida e seleciona uma qtd delas aleatoriamente

list_cheia = []
for i in range(regiao.shape[0]):
  for j in range(regiao.shape[1]):
    if regiao[i][j] == 1:
      list_cheia.append((i,j))
print("Pixels na regiao escolhida:", len(list_cheia))

coords = []
for i in range(qtd_coords):
  coords.append(list_cheia[random.randint(0, len(list_cheia)-1)])

coords = np.array(coords)
print(coords.shape)


#cria uma matriz com as coords na lista e seus vizinhos, para visualizar melhor quais são
matriz_coords = np.zeros_like(regiao)
print(matriz_coords.shape)

for coord in coords:
  for i in range(-1,2): #(-2,2)
    for j in range(-1,2): #(-2,2)
      if coord[0] >= -i and coord[0] +i <= matriz_coords.shape[0] and\
      coord[1] >= -j and coord[1]+j <= matriz_coords.shape[1]:
        matriz_coords[coord[0]+i][coord[1]+j] = 1

JUNTA = regiao + 2*matriz_coords

plt.figure(figsize=(20, 5))
plt.subplot(131)
plt.imshow(array_img, cmap='gray')
plt.subplot(132)
plt.imshow(img_esperada, cmap='gray')
plt.subplot(133)
plt.imshow(JUNTA);

"""#SEGMENTAÇÃO"""

#Escolher a img_base, o limiar, o fator, e a lista de coordenadas

img_base = array_img
limiar   = 0.025
fator    = 1
#coords  = np.array([[130,390]])  #define aqui ou pula caso já tenha a lista coords



if len(img_base.shape) == 2:
  img_base = np.array(img_base.copy().reshape(img_base.copy().shape+(1,)))

imagem_segmentada = region_growing(img_base.copy(), coords, limiar)



######## forma uma segunda imagem ajustada ###################

imagem_segmentada_2 = imagem_segmentada.copy()

for i in range(fator, imagem_segmentada.shape[0]-fator):
  for j in range(fator, imagem_segmentada.shape[1]-fator):
    if imagem_segmentada[i-fator][j-fator] + imagem_segmentada[i+fator][j+fator] == 2 or \
    imagem_segmentada[i-fator][j+fator] + imagem_segmentada[i+fator][j-fator] == 2:
      for p in range(-fator,fator+1):
        for q in range(-fator,fator+1):
          imagem_segmentada_2[i+p][j+q] = 1

##############################################################


plt.figure(figsize=(20, 5))
plt.subplot(131)
plt.imshow(img_base)
plt.subplot(132)
plt.imshow(imagem_segmentada, cmap='gray')
plt.subplot(133)
plt.imshow(imagem_segmentada_2, cmap = 'gray');

"""# MÉTRICAS PARA COMPARAÇÃO"""

print("TP: ",IoU(esperada23_resized, imagem_segmentada)[0]*100) #true positive
print("FP: ",IoU(esperada23_resized, imagem_segmentada)[1]*100) #false positive
print("FN: ",IoU(esperada23_resized, imagem_segmentada)[2]*100) #false negative


plt.figure(figsize=(20, 5))
plt.subplot(131)
plt.imshow(esperada23_resized, cmap='gray')
plt.subplot(132)
plt.imshow(imagem_segmentada, cmap='gray');

"""# POLÍGONO"""

#gravando a imagem segmentada em .tif
print("Saving segmented image...")
filename = 'imagem_segment_south_mayo2024_v2.tif' #1 - colocar o nome da imagem original
gt = gdal.Open(filename)
band = gt.GetRasterBand(1)

# pega as dimensoes
cols = gt.RasterXSize
rows = gt.RasterYSize

if band.GetMinimum() is None or band.GetMaximum()is None:
    band.ComputeStatistics(0)
band.GetMetadata()

# cria o .tif de saida
segmentedImageFile = "segmented_south_0025.tif" #2 - escolher nome do tif de saida

driver = gdal.GetDriverByName('GTiff')
outDs = driver.Create(segmentedImageFile, cols, rows, 1, gdal.GDT_Byte)
outDs.SetGeoTransform(gt.GetGeoTransform())
outDs.SetProjection(gt.GetProjection())
outBand = outDs.GetRasterBand(1)
outBand.WriteArray(imagem_segmentada) #3 - mudar a array usada para gravar
outBand.FlushCache()
del outDs

print("Segmented image saved.")

#gravando o .tif em .shp
imgname = 'segmented_south_0025.tif' #4 mudar nome da imagem tif a ser poligonizada

#abre a imagem, pega a banda e le como array
raster = gdal.Open(imgname)
band = raster.GetRasterBand(1)
band.ReadAsArray()

#pega as projeções da imagem para aplicar no shp
proj = raster.GetProjection()
shp_proj = osr.SpatialReference()
shp_proj.ImportFromWkt(proj)

shpname  = "segmented_south_0025.shp" #5-definir o nome do shapefile de saída

call_drive = ogr.GetDriverByName('ESRI Shapefile')
create_shp = call_drive.CreateDataSource(shpname)

shp_layer = create_shp.CreateLayer(shpname, srs = shp_proj)

new_field = ogr.FieldDefn(str('ID'), ogr.OFTInteger)
shp_layer.CreateField(new_field)

#funcao para transformar em poligonos
gdal.Polygonize(band, None, shp_layer, 0, [], callback=None)

create_shp.Destroy()
del raster